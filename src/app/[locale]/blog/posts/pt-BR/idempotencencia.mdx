---
title: "Idempotência: Importância e papel na construção de aplicações resilientes"
publishedAt: "2025-01-28"
summary: "Every career is a journey, filled with challenges, growth, and those significant moments that mark a shift in our path."
tag: "tecnologia"
---

Se você está na carreira de desenvolvimento de software há um tempo já deve ter se deparado com o conceito de idempotência. Mas o que isso significa e qual sua importância na construção de aplicações resilientes a falhas? Vem comigo que é sobre isso que vamos falar hoje!

## O Conceito de Idempotência

Dizemos que uma operação é idempotente quando ela gera o mesmo resultado ao ser executada uma ou mais vezes. Mas tenha cuidado, isso não significa que a resposta será a mesma ou que essa operação não gerará efeitos colaterais, mas sim que ao **repetir** essa ação não serão gerados efeitos colaterais no servidor. Mas o que isso quer dizer na prática?

Vamos tomar como exemplo uma operação <span style={{color: "#E74C3C "}}>DELETE</span> em um recurso de uma API REST. Se implementada corretamente, na primeira execução da operação o recurso deve ser deletado com sucesso e um status **204 No Content** deve ser retornado. Já na segunda execução dessa operação é esperado um retorno com um status diferente, como **404 Not Found** indicando que o recurso deixou de existir. No entanto é possível notar que o estado da aplicação continua o mesmo do obtido pela requisição anterior, isso significa que a operação é idempotente!

As operações em APIs REST como <span style={{color: "#2ECC71"}}>GET</span>, <span style={{color: "#F39C12" }}>PUT</span>, <span style={{color: "#95A5A6"}}>HEAD</span> e o <span style={{color: "#9B59B6" }}>OPTIONS</span>, se implementadas corretamente, também devem ser idempotentes, enquanto outras como <span style={{color: "#3498DB"}}>POST</span> não, pois a cada requisição é esperado que um novo recurso seja criado, gerando efeitos colaterais. 

O método <span style={{color: "#F1C40F"}}>PATCH</span> no entanto é alvo de controvérsias quanto a presença ou não de idempotência. Como fica a critério do desenvolvedor atribuir o comportamento de cada chamada HTTP em uma API o que foi discutido nem sempre é a regra.

## Qual a importância da Idempotência?

Quando vamos projetar aplicações que necessitam de ser resilientes a falhas pode ser necessário considerar estratégias de retentativa em alguns fluxos, e para isso é importante que as operações efetuadas não levem a aplicação à estados inconsistentes. 

Imagine ter recebido um erro ao realizar um pagamento e, ao tentar novamente, descobrir que o valor foi debitado da sua conta duas vezes? Ou então possuir uma aplicação que escuta as mensagens de uma fila utilizando o Amazon SQS, que pode ocasionalmente <a href={"https://docs.aws.amazon.com/pt_br/AWSSimpleQueueService/latest/SQSDeveloperGuide/standard-queues-at-least-once-delivery.html"} target={"_blank"} rel={"noopener noreferrer"}>entregar uma mensagem mais de uma vez</a>, o que é conhecido como **at-least-once delivery**? É preciso ter certeza que é seguro realizar uma retentativa e é ai que entra a importância da idempotência!

Ao chamar um método idempotente mais de uma vez não precisamos nos preocupar com estados inconsistentes gerados por retentativas, pois sabemos que não haverão efeitos colaterais nas chamadas subsequentes. Por isso é importante conhecer estratégias para implementação de idempotência mesmo em casos onde ela não é tida por padrão como no método POST que mencionamos anteriormente e é isso que abordaremos a seguir.

## Implementando Idempotência

Em alguns casos, pode ser necessário tornar um método POST idempotente.
Não gostaríamos de criar mais de uma conta ao fazermos múltiplas requisições idênticas para o servidor, não é mesmo? 

Existem alguns métodos que podem ser aplicados para tornar um método POST idempotente, como por exemplo o uso de uma **chave de idempotência**. A chave de idempotência é um campo que podemos adicionar no recurso e que deve ser preenchido com informações que tornam aquele recurso único. 

No caso de criação de uma conta citado acima poderíamos usar o **CPF** como chave de idempotência. Para garantir que dois recursos não tenham a mesma chave de idempotência podemos criar uma regra na camada da aplicação ou então tornar aquele campo **único** na camada do banco de dados, evitando duplicações.

Quando não temos um campo óbvio que torne aquele recurso único como no caso do CPF uma solução possível é o uso de uma **hash** do recurso criada com os valores dos campos de interesse que tornam o recurso único. Más algum cuidado precisa ser tomado quando utilizamos essa alternativa, pois é possível que haja <a href={"https://en.wikipedia.org/wiki/Hash_collision"} target={"_blank"} rel={"noopener noreferrer"}>colisões de hash</a>, impedindo a publicações de recursos mesmo que eles sejam diferentes.

Quando a idempotência precisa ser garantida apenas por um intervalo determinado de tempo podemos usar um banco de dados em memória como o <a href={"https://redis.io/"} target={"_blank"} rel={"noopener noreferrer"}>redis</a> para armazenar a chave de idempotência, especificando um tempo de expiração para esse valor. Dessa forma temos menos chances de criar um problema devido á uma colisão de hash.

## Exemplo em Kotlin com Spring

Para exemplificar como é possível implementar as estratégias citadas eu criei um <a href={"https://github.com/daanrsantiago/idempotency-example"} target={"_blank"} rel={"noopener noreferrer"}>repositório no github</a>. O projeto é bem simples a para roda-lo basta 

<CodeBlock className="my-24"
    compact
    codeInstances={[
        {
            code: 'var a = "teste"\nfun (b: String) \{\n    val c = "teste2"\n\}',
            label: 'Next.js',
            language: 'kotlin'
        },
    ]}
    copyButton
/>